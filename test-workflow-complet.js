/**
 * ==============================================================================
 * Test Workflow Complet - NurseLinkAI
 * ==============================================================================
 *
 * Ce script teste le flux complet de g√©n√©ration de contrats automatiques :
 * 1. Publication d'une mission
 * 2. Matching avec des candidats
 * 3. Acceptation de candidature par l'√©tablissement
 * 4. G√©n√©ration automatique du contrat
 * 5. Signature √©lectronique du candidat
 * 6. V√©rification par l'√©tablissement
 * ==============================================================================
 */

const BASE_URL = 'http://localhost:3000/api';

// Donn√©es de test
const TEST_DATA = {
  establishment: {
    id: 'user-test-etablissement',
    name: 'H√¥pital Test',
    email: 'test@hopital.fr'
  },
  nurse: {
    id: 'user-marie-candidat',
    name: 'Marie Leroy',
    email: 'marie.leroy@email.com'
  },
  mission: {
    title: 'Mission Test Workflow Complet',
    description: 'Mission de test pour v√©rifier le flux complet de g√©n√©ration de contrats',
    specialization: 'cardiology',
    startDate: '2025-07-15',
    endDate: '2025-07-20',
    hourlyRate: 26,
    shift: 'day',
    location: 'Paris'
  }
};

class WorkflowTester {
  constructor() {
    this.results = [];
    this.currentStep = 0;
  }

  log(step, message, data = null) {
    this.currentStep++;
    const timestamp = new Date().toISOString();
    console.log(`\n${this.currentStep}. [${timestamp}] ${step}: ${message}`);
    if (data) {
      console.log('   Donn√©es:', JSON.stringify(data, null, 2));
    }

    this.results.push({
      step: this.currentStep,
      timestamp,
      action: step,
      message,
      data
    });
  }

  async testStep(stepName, testFunction) {
    try {
      this.log(stepName, 'D√©marrage...');
      const result = await testFunction();
      this.log(stepName, '‚úÖ Succ√®s', result);
      return result;
    } catch (error) {
      this.log(stepName, `‚ùå Erreur: ${error.message}`, { error: error.toString() });
      throw error;
    }
  }

  async makeRequest(endpoint, options = {}) {
    const url = `${BASE_URL}${endpoint}`;
    const response = await fetch(url, {
      headers: {
        'Content-Type': 'application/json',
        ...options.headers
      },
      ...options
    });

    const data = await response.json();

    if (!response.ok) {
      throw new Error(`HTTP ${response.status}: ${data.error || data.message || 'Erreur inconnue'}`);
    }

    return data;
  }

  // √âTAPE 1: V√©rification des donn√©es de base
  async verifyBaseData() {
    return await this.testStep('V√©rification des donn√©es de base', async () => {
      // V√©rifier que les utilisateurs de test existent
      const contracts = await this.makeRequest('/contracts/test-list');

      return {
        contractsCount: contracts.contracts.length,
        message: 'Donn√©es de base v√©rifi√©es'
      };
    });
  }

  // √âTAPE 2: Cr√©ation d'une mission de test
  async createTestMission() {
    return await this.testStep('Cr√©ation d\'une mission de test', async () => {
      const missionData = {
        ...TEST_DATA.mission,
        establishmentId: TEST_DATA.establishment.id
      };

      const mission = await this.makeRequest('/missions', {
        method: 'POST',
        body: JSON.stringify(missionData)
      });

      return {
        missionId: mission.id,
        title: mission.title,
        status: mission.status
      };
    });
  }

  // √âTAPE 3: Simulation du matching IA
  async simulateAIMatching(missionId) {
    return await this.testStep('Simulation du matching IA', async () => {
      const matchingData = {
        missionId: missionId,
        maxCandidates: 5,
        maxDistance: 30,
        minExperience: 2
      };

      const matches = await this.makeRequest('/matching/mission', {
        method: 'POST',
        body: JSON.stringify(matchingData)
      });

      return {
        candidatesCount: matches.length,
        topCandidate: matches[0] ? {
          id: matches[0].nurseId,
          name: matches[0].name,
          score: matches[0].score
        } : null
      };
    });
  }

  // √âTAPE 4: Cr√©ation d'une candidature
  async createApplication(missionId) {
    return await this.testStep('Cr√©ation d\'une candidature', async () => {
      const applicationData = {
        missionId: missionId,
        nurseId: TEST_DATA.nurse.id,
        coverLetter: 'Candidature de test pour le workflow complet',
        hourlyRate: TEST_DATA.mission.hourlyRate,
        availability: {
          startDate: TEST_DATA.mission.startDate,
          endDate: TEST_DATA.mission.endDate,
          shifts: [TEST_DATA.mission.shift]
        }
      };

      const application = await this.makeRequest('/missions/applications', {
        method: 'POST',
        body: JSON.stringify(applicationData)
      });

      return {
        applicationId: application.id,
        status: application.status,
        nurseId: application.nurseId
      };
    });
  }

  // √âTAPE 5: Acceptation de la candidature par l'√©tablissement
  async acceptApplication(applicationId) {
    return await this.testStep('Acceptation de la candidature', async () => {
      const acceptanceData = {
        status: 'accepted',
        feedback: 'Candidature accept√©e pour le test de workflow'
      };

      const result = await this.makeRequest(`/missions/applications/${applicationId}/status`, {
        method: 'PATCH',
        body: JSON.stringify(acceptanceData)
      });

      return {
        applicationStatus: result.application.status,
        contractGenerated: !!result.contract,
        contractId: result.contract?.id
      };
    });
  }

  // √âTAPE 6: V√©rification du contrat g√©n√©r√©
  async verifyGeneratedContract(contractId) {
    return await this.testStep('V√©rification du contrat g√©n√©r√©', async () => {
      const contracts = await this.makeRequest('/contracts/test-list');
      const contract = contracts.contracts.find(c => c.id === contractId);

      if (!contract) {
        throw new Error('Contrat non trouv√©');
      }

      return {
        contractId: contract.id,
        status: contract.status,
        missionId: contract.missionId,
        nurseId: contract.nurseId,
        establishmentId: contract.establishmentId,
        terms: contract.terms,
        expiresAt: contract.expiresAt
      };
    });
  }

  // √âTAPE 7: Signature √©lectronique du candidat
  async signContractByNurse(contractId) {
    return await this.testStep('Signature √©lectronique du candidat', async () => {
      const signatureData = {
        contractId: contractId,
        consent: true,
        userAgent: 'Test Workflow Script',
        ip: '127.0.0.1'
      };

      const result = await this.makeRequest(`/contracts/${contractId}/sign`, {
        method: 'POST',
        body: JSON.stringify(signatureData)
      });

      return {
        contractStatus: result.contract.status,
        signatures: result.contract.signatures,
        message: result.message
      };
    });
  }

  // √âTAPE 8: V√©rification finale du contrat
  async verifyFinalContract(contractId) {
    return await this.testStep('V√©rification finale du contrat', async () => {
      const contracts = await this.makeRequest('/contracts/test-list');
      const contract = contracts.contracts.find(c => c.id === contractId);

      if (!contract) {
        throw new Error('Contrat final non trouv√©');
      }

      return {
        contractId: contract.id,
        finalStatus: contract.status,
        hasNurseSignature: !!contract.signatures?.nurse,
        hasEstablishmentSignature: !!contract.signatures?.establishment,
        isCompleted: contract.status === 'signed_nurse' || contract.status === 'completed'
      };
    });
  }

  // Ex√©cution du workflow complet
  async runCompleteWorkflow() {
    console.log('üöÄ D√©marrage du test de workflow complet NurseLinkAI');
    console.log('=' .repeat(60));

    try {
      // √âtape 1: V√©rification des donn√©es de base
      await this.verifyBaseData();

      // √âtape 2: Cr√©ation d'une mission
      const mission = await this.createTestMission();

      // √âtape 3: Simulation du matching
      await this.simulateAIMatching(mission.missionId);

      // √âtape 4: Cr√©ation d'une candidature
      const application = await this.createApplication(mission.missionId);

      // √âtape 5: Acceptation de la candidature
      const acceptance = await this.acceptApplication(application.applicationId);

      // √âtape 6: V√©rification du contrat g√©n√©r√©
      await this.verifyGeneratedContract(acceptance.contractId);

      // √âtape 7: Signature du candidat
      await this.signContractByNurse(acceptance.contractId);

      // √âtape 8: V√©rification finale
      await this.verifyFinalContract(acceptance.contractId);

      console.log('\nüéâ WORKFLOW COMPLET R√âUSSI !');
      console.log('=' .repeat(60));
      console.log('‚úÖ Toutes les √©tapes ont √©t√© ex√©cut√©es avec succ√®s');
      console.log('üìã R√©sum√© du workflow:');
      console.log(`   - Mission cr√©√©e: ${mission.title}`);
      console.log(`   - Candidature accept√©e: ${application.applicationId}`);
      console.log(`   - Contrat g√©n√©r√©: ${acceptance.contractId}`);
      console.log(`   - Contrat sign√© par le candidat`);
      console.log(`   - Workflow complet valid√©`);

      return {
        success: true,
        steps: this.results,
        summary: {
          missionId: mission.missionId,
          applicationId: application.applicationId,
          contractId: acceptance.contractId
        }
      };

    } catch (error) {
      console.log('\n‚ùå WORKFLOW √âCHOU√â');
      console.log('=' .repeat(60));
      console.log(`Erreur √† l'√©tape ${this.currentStep}: ${error.message}`);

      return {
        success: false,
        error: error.message,
        steps: this.results,
        failedAtStep: this.currentStep
      };
    }
  }
}

// Ex√©cution du test
async function main() {
  const tester = new WorkflowTester();
  const result = await tester.runCompleteWorkflow();

  console.log('\nüìä R√âSULTAT FINAL:');
  console.log(JSON.stringify(result, null, 2));

  process.exit(result.success ? 0 : 1);
}

// Gestion des erreurs non captur√©es
process.on('unhandledRejection', (reason, promise) => {
  console.error('Erreur non g√©r√©e:', reason);
  process.exit(1);
});

// Lancement du test
main().catch(error => {
  console.error('Erreur fatale:', error);
  process.exit(1);
});
